package leetcode.Medium;

/**
 * Created by Administrator on 2016/8/23.
 * 这道题的难点其实在于证明为什么拆出足够多的 3 就能使得乘积最大。下面我就试着证明一下。
 首先证明拆出的因子大于 4 是不行的。设 x 是一个因子，x>4，那么可以将这个因子再拆成两个因子 x−2 和 2，易证 (x−2)×2>x。所以不能有大于 4 的因子。
 4 这个因子也是可有可无的，4=2+2，4=2×2。因此 4 这个因子可以用两个 2 代替。
 除非没有别的因子可用，1 也不能选作因子。一个数 x 当它大于 3 时，有 (x−2)×2>(x−1)×1。
 这样呢，就只剩下 2 和 3 这两个因子可以选了。下面再证明 3 比 2 好。
 一个数 x=3m+2n，那么 f=3^m×2^n=3^m×2^[(x−3m)/2] 可以对它取个对数。
 lnf=mln3+[(x−3m)/2]*ln2=(x/2)*ln2+(ln3−(3/2)*ln2)m
 其中 ln3−(3/2)*ln2>0 所以 f 是 m 的增函数，也就是说 m 越大越好。所以 3 越多越好。
 再多说一句，如果拆出的因子不限于整数的话，可以证明e=2.718… 是最佳的选择。感兴趣的可以试着证明一下。
 */
public class Integer_Break {
    public static int integerBreak(int n) {
        int[] dp=new int[n+1];
        dp[1]=1;
        dp[2]=1;
        dp[3]=2;
        dp[4]=4;
        for(int i=5;i<=n;i++){
            dp[i]=Math.max(dp[i-3]*3, dp[i-2]*2);
        }
        return dp[n];
    }
}
